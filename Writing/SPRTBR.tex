\documentclass[12pt,letterpaper]{article}
\usepackage{natbib}

%Packages
\usepackage{pdflscape}
\usepackage{fixltx2e}
\usepackage{textcomp}
\usepackage{fullpage}
\usepackage{float}
\usepackage{latexsym}
\usepackage{url}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{array}
\usepackage[version=3]{mhchem}
\usepackage{ifthen}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{amstext}
\usepackage{enumerate}
\usepackage[osf]{mathpazo}
\usepackage{dcolumn}
\usepackage{lineno}
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{.}{#1}}

\pagenumbering{arabic}


%Pagination style and stuff
\linespread{2}
\raggedright
\setlength{\parindent}{0.5in}
\setcounter{secnumdepth}{0} 
\renewcommand{\section}[1]{%
\bigskip
\begin{center}
\begin{Large}
\normalfont\scshape #1
\medskip
\end{Large}
\end{center}}
\renewcommand{\subsection}[1]{%
\bigskip
\begin{center}
\begin{large}
\normalfont\itshape #1
\end{large}
\end{center}}
\renewcommand{\subsubsection}[1]{%
\vspace{2ex}
\noindent
\textit{#1.}---}
\renewcommand{\tableofcontents}{}
%\bibpunct{(}{)}{;}{a}{}{,}

%---------------------------------------------
%
%       START
%
%---------------------------------------------

\begin{document}

%Running head
\begin{flushright}
Version dated: \today
\end{flushright}
\bigskip
\noindent RH: Branch swapping algorithm

\bigskip
\medskip
\begin{center}

\noindent{\Large \bf SPR/TBR.} %TG: Need a title!
\bigskip

\noindent {\normalsize \sc Thomas Guillerme$^1$$^*$, and Martin D. Brazeau$^1$}\\ %TG: Author order can be swapped of course! There's only a finite combination of 2 elements anyway!
\noindent {\small \it 
$^1$Imperial College London, Silwood Park Campus, Department of Life Sciences, Buckhurst Road, Ascot SL5 7PY, United Kingdom.\\}
\end{center}
\medskip
\noindent{*\bf Corresponding author.} \textit{t.guillerme@imperial.ac.uk}\\  %TG: Same as above
\vspace{1in}

%Line numbering
\modulolinenumbers[1]
\linenumbers

%---------------------------------------------
%
%       ABSTRACT
%
%---------------------------------------------

\newpage
\begin{abstract}
blablabla
\end{abstract}

\noindent (Keywords: )\\

\vspace{1.5in}

\newpage 


%---------------------------------------------
% LaTeX tips for modifying/editing the document:
%---------------------------------------------
% - You can comment using the percentage sign. I suggest you use the % sign alone for commenting out sections of the text:
%       e.g. "This is a really long sentence %because this sentence is very long." Here the % is used for ignoring the end of the sentence (but for some reason you want to keep track of it).%
%       For comments as in verbose comments, I suggest you use "%MB:":
%       e.g. "This is a really long sentence %because this sentence is very long. %MB: yeah, no shit!" 
% - For optimal version control, write only one sentence per line (for more precise track changes)
% - To build the pdf, use command+B in Sublime.
% - Because of the bibliography, the pdf needs to be build in the same folder that contains "References.bib" and "sysbio.bst"
% - For citing papers, you must put their bibtex reference in the "References.bib" file and then you can use the following sysbio tags:
%        \cite{bibtexBob2000} for citing within a sentence: "Bob (2000)"
%        \citep{bibtexBob2000} for citing within brackets: "(Bob, 2000)"
%        \citep[Before:][-After]{bibtexBob2000} for citing within brackets with additional text: "(Before: Bob, 2000 -After)"
%        \citealt{bibtexBob2000} for citing without brackets: "Bob, 2000"
%        You can put more cites in each \cite tag by separating them with commas.
% - For equation, find every details here: https://en.wikibooks.org/wiki/LaTeX/Mathematics
% - For titles and stuff, the hierarchy goes \section{}, \subsection{}, \subsubsection{} and so forth...
% - For bullet points or enumerations you can use:
%       \begin{itemize}
%           \item my first bullet point/enumeration
%       \end{itemize}
%       With replacing "itemize" by "enumerate" for enumeration.




%---------------------------------------------
%
%       INTRODUCTION
%
%---------------------------------------------

\section{Introduction}

Phylogenetics, as the way to infer the relations between organisms, is at the base of literally every endeavour in modern biology ans has also important ramifications outside of biological sciences (e.g. linguistics - \citealt{Bouckaert24082012} -, computer sciences [CITATION], mathematics [CITATION], etc.).
Although many of the methods in phylogenetics, ranging from gene alignments \citep[e.g.][]{Tan01092015} to tree comparisons \citep[e.g.][]{kuhner2015treComparison} are widely studied, used and taught %TG: Cite recent classic phylo book here.
one crucial aspect, tree rearrangement methods (i.e. branch swapping), is often ignored or over-looked by most biologists.
In fact, these methods are used during crucial steps of the phylogenetic inference procedure (i.e. ``building'' trees): (1) building the starting tree, (2) heuristic tree search and (3) inferring the tree parameters whether based on optimality criteria \citep[e.g. maximum parsimony; ][]{swofford2003paup} or probabilistic methods \citep[e.g. likelihood or Bayesian; ][]{Stamatakis21012014,Ronquist2012mrbayes}.
Moreover, they are also widely use in post-tree inference tasks such as tree comparisons \citep[e.g.][]{allen2001subtree,kuhner2015treComparison}, node support estimation \citep[e.g][]{goloboff2014bias} or specific analysis such as horizontal genes transfer \citep[e.g.][]{mcfadden1995something,bordewich2005computational} to cite only a few.
%TG:Linear model simplification has parallels too? Similar to search strategies in integer and mixed integer programming?


Classic literature will visit redundant trees \citep{allen2001subtree,felsenstein2004inferring}.
Problems with revisiting topologies \citep{goloboff2014bias}
Visiting redundant tree topologies (i.e. redundant branch swaps) creates two major problems: (1) it costs time and (2) it can bias the tree search.
First, although time does not seem an issue for a single branch swap repeated twice (@@@ CPU time), when scaling it to modern phylogenetic inference (i.e. repeated @@@ times), it becomes one of the main bottleneck of phylogenetic software [CITE?].
Second, repeating the same swap several times involves visiting some topologies more than other.
In optimisation search algorithm that visit all the possible solution (\textit{Hard} heuristic search) %TG: probably not the correct term here. I mean looking for all solutions
 this might not pose any problem but because of the sheer amount of branch swaps to visit, this approach is rarely used.
In fact, when the heuristic search only visits some possible solutions (and then continues optimisation from there if the topology is better) this can create problems by having a higher probability of landing on a specific tree topology island since the probability of obtaining any topology by branch swap will not be equal (some topologies might be more visited by chance).
More concretely, for a tree with $n$ taxa, branch swapping algorithms can produce $M$ topologies including $m$ similar ones.
If the tree search algorithm is set to subsample $m$ topologies only, it can be possible to subsample only the $m$ similar topologies thus being literally ineffective at exploring tree space.

Solutions have been proposed by people in forms of different algorithm implementation that avoid redundant topologies to be visited \citep{allen2001subtree}.
Although highly efficient these algorithm can be described in some cryptic manners.

Problem being explained in Fig2 \cite{goloboff2014bias}
Unique swaps also can introduce some bias when the positions are not considered randomly (which is most often not the case - using pre/post-order traversals) \citep{goloboff2014bias}.


%Something about writing code for humans not computers? (i.e. non-cryptic/obfuscating coding practices)

Avoiding redudant swaps described in \cite{allen2001subtree} or in \cite{goloboff2014bias}.

Here we will review two common tree swapping algorithms (Subtree Pruning and Regrafting - SBR - and Tree Bisection and Reconnection - TBR) and propose a mathematically equivalent but more practical and intuitive definition of the algorithms.
The improvement presented in this paper is aimed to make branch swapping algorithms implementation more intuitive.
We do not claim priority or originality on this method that is certainly already implemented in many softwares and was ``discovered'' empirically by many coders.
We look at SPR as rerooting + branching.


\section{Branch swapping}

The number of rooted binary trees possible with $n$ taxa is $(2n-3)!!$ ($(2n-5)!!$ for unrooted trees!) therefore, it becomes computationally impossible to explore all topologies for any serious number of taxa (e.g. for 14 taxa, there are more than a trillion topologies to visit - $7.9\times10^{12}$).




% \begin{equation}
%     (2n-3)!!=(2n-3)\times(2n-5)\times...\times3=\frac{(2n-2)!}{2^{n-1}(n-1)!}
% \end{equation}



\section{SPR and TBR}

\subsection{Tree elements definition}
\begin{itemize}
    \item a \textbf{tip} is any leaf of the tree (degree 1 vertices) that is connected to only one node.
    \item a \textbf{node} is formed by the connection of tips or nodes. In a binary tree, a node has exactly one ancestor (or parent) and two descendants.
    \item an \textbf{edge} is any single connection between two nodes or a node and a tip.
    \item the \textbf{root} is the single edge that is only connected to one node (and nothing).
\end{itemize}
Any bifurcating (i.e. fully resolved) tree with $n$ tips has $2n-1$ nodes and $2n-2$ edges ($n-2$ internal ones) if rooted and $2n-2$ nodes and $2n-3$ edges ($n-3$ internal ones) if unrooted.

Definitions: \cite{allen2001subtree,felsenstein2004inferring}

\subsubsection{Subtree Pruning and Regrafting (SPR)}
This method consists in removing any subtree from the original tree (including all trees with only one tip and one edge, i.e. the terminal nodes) and reinserting it along every edges back on the original tree \citep[see Fig \ref{Figure_Felsenstein};]{felsenstein2004inferring}.
In more other words, a tree with $n$ taxa, is split into two trees: the target tree with $n_{target}$ taxa and the subtree with $n_{subtree}$ taxa (where $n_{subtree} \leq 1$).
The substree is then reinserted in the $2n_{1}-3$ positions available on the target tree \citep{felsenstein2004inferring}.
Thus, the total number of SPR rearangements for an original tree with $n$ taxa is $4(n-3)(n-2)$.
Redundant tree topologies occur when the subtree is rebranched on it's original position and on one of the neighbouring edge to it's original position \citep{allen2001subtree}.
%TG: + more rules? more properties?

It is then possible to calculate the precise minimum number of SPR rearrangements to cover all topologies without redundant swaps as:

\begin{equation}
    \text{Total SPR}={\overbrace{(2n-3)}^{\text{edges}}} {\overbrace{(2n-4)}^{(\text{edges} - 1)}} % TG: or use \sum{SPR}?
\end{equation}

Where $(2n-3)$ is the number of subtrees one can obtain from an original $n$ taxa tree and $(2n-4)$ are the number of reinsertions possible from these subtrees on the target trees \cite{allen2001subtree}.
From this total, we can remove the $6(n-2)$ trees corresponding to regrafting the subtrees adjacent to their pruning edge \citep[resulting in the same topology; ][]{allen2001subtree}, and the $8(n-3)$ trees corresponding to regrafting the subtrees to the edge neighbouring their pruning edge \citep{allen2001subtree}.
Thus: 

\begin{equation}
    \text{Minimum SPR}=4(n-3)(n-4) %(2n-3)(2n-4) - 6(2n-2) - 8(n-3) 
\end{equation}

\citep[c.f.][]{felsenstein2004inferring}

\subsubsection{Tree Bisection and Reconnection (TBR)}
This method consists in breaking the original tree into two distinct trees.
One of them is then rerooted on every of its edges and then rebranched on any of the edges of the second tree.
For a tree with $n$ taxa separated into two trees with $n_{1}$ taxa and $n_{2}$ taxa, there will be $(2n_{1}-3)(2n_{2}-3)$ possible ways to recombine the them \citep{felsenstein2004inferring} with $n_{1}$ and $n_{2}$ varying from $2$ to $n-2$ depending on the tree topology.
This operation can be repeated for all the internal edges in the original tree, thus the maximum TBR can be:
\begin{equation}
    \text{Maximum TBR} = \overbrace{(n-3)}^{\text{internal edges}} \sum_{i=2}^{n-2} (2i-3)(2(n-i)-3) %TG: Check! Summation might be incorrect
\end{equation}
Where $i$ and $n-i$ corresponds respectively to the size of the smallest and biggest trees resulting from splitting the original tree.

The minimum number of TBR rearrangement is depending on the tree topology
Where both $n_{1}$ and $n_{2}$ can vary from $2$ to $n-2$ depending on the tree topology.
In fact the minimum

\begin{figure}[!htbp]
\centering
   \includegraphics[width=0.8\textwidth]{Figure/FelsensteinFigure.pdf}
\caption{\scriptsize{SPR and TBR description. Modified from \cite{felsenstein2004inferring}, Figure 4.5 and 4.6. \textbf{SPR-1:} blabla; \textbf{SPR-2:} blabla; \textbf{SPR-3:}blabla; \textbf{TBR-1:} blabla; \textbf{TBR-2:} blabla (note that when the sub-tree is reroot on position \textit{1}, the rearrangement is equivalent to a SPR); \textbf{TBR-3:}blabla.}}
\label{Figure_Felsenstein}
\end{figure}


\section{Other}
NNI
tree-fusing
Genetic algorithms
Tree windows and sectorial search
Coalescent with Recombination

\section{Improved algorithm}

%Check how it's done in different softwares: RAxML, phangorn?

\subsection{Neighbour Rule}
Neighbour Rule described \citep[in other words;][]{allen2001subtree}.

\subsection{SPR as TRB (Subtree Rerooting and Branching)}

\section{Conclusion}

This way is not different than the classic SPR/TBR but it's a better implementation.

\section{Data availability and reproducibility}
%TG: Probably some link to morphy


\section{Acknowledgments}
European Research Council under the European Union’s Seventh Framework Programme (FP/2007–2013)/ERC Grant Agreement number 311092.


\bibliographystyle{sysbio}
\bibliography{References}

\end{document}



% For a tree ((A,B),C,(D,E));

% 1 - Clip A and rebranch everywhere:
% ((A,B),C,(D,E));
% (B,(C,A),(D,E));
% (B,C,((A,D),E));
% (B,C,(A,(A,E)));
% That’s 4 trees including the original one!
% If reach 0 trees, go to 4.

% 2 - Clip (A,B) and rebranch everywhere:
% blablabal…
% 3 trees
% If reach 0 trees, go to 4.

% 3- Clip ((A,B),C) and rebranch everywhere:
% blabalbalba…
% 0 trees
% If reach 0 trees, go to 4.

% 4 - Clip !A, rebranch everywhere BUT not to the neighbour branches.
% blablalba.
% 2 trees * (number of tips - 1)  = 8 // The -1 is A
% If reach 0 trees, go to 6.

% 5 - Clip all dichotomies !(A.B), rebranch everywhere BUT not to the neighbour branches/
% blabalbal…
% 0 trees.

% If reach 0 trees, go to 6.
% 6 - Stop

% That’s all folks! Using this algorithm you get… 30 trees!
% Okay, I think it look nicer on paper (I’ll show you tomorrow morning) but it works totally! One only detail that we can improve (and I suspect that’s what PAUP is fucking up) is that step 2, (as step 1) re-includes the original tree (hard to show on unrooted onewicks but obvious on paper). We can reach our 29 trees by removing that one!